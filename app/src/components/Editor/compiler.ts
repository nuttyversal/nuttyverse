import { evaluate } from "@mdx-js/mdx";
import { Effect } from "effect";
import { UnknownException } from "effect/Cause";
import remarkMath from "remark-math";
import KaTeX from "katex";
import { JSX, Setter } from "solid-js";
import * as runtime from "solid-js/h/jsx-runtime";
import { Plugin } from "unified";
import { Node, Parent } from "unist";
import { visit } from "unist-util-visit";
import { SKIP, visitParents } from "unist-util-visit-parents";
import { CodeBlock } from "~/components/CodeBlock";
import { Link } from "~/components/Link";
import { ElementBlock, EmptyBlock, SourceMap } from "./sync/types";

/**
 * A component registry that maps component names to components.
 * Components must be registered here to be used in MDX content.
 */
const componentRegistry = {
	CodeBlock,
	Link,
};

/**
 * An effect that compiles MDX content into JSX.
 */
const compileMdx = (
	mdx: string,
	setSourceMap: Setter<SourceMap>,
): Effect.Effect<JSX.Element, UnknownException> => {
	return Effect.tryPromise(async () => {
		try {
			const { default: renderContent } = await evaluate(mdx, {
				...runtime,
				remarkPlugins: [remarkMath, rewriteCodeBlocks],
				rehypePlugins: [
					renderKaTeX,
					rewriteLinks,
					createSourceMap(setSourceMap),
				],
			});

			return renderContent({
				components: componentRegistry,
			});
		} catch (e) {
			return Effect.fail(new Error(`Failed to compile MDX: ${e}`));
		}
	});
};

/**
 * Rewrite code block elements into `CodeBlock` component instances.
 */
const rewriteCodeBlocks: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RemarkElement = (Node | Parent) & {
		lang: string;
		value: string;
	};

	return (tree) => {
		visit(
			tree,
			"code",
			(node: RemarkElement, index, parent: RemarkElement) => {
				if (parent != null && index != null) {
					const component = {
						type: "mdxJsxFlowElement",
						name: "CodeBlock",
						attributes: [
							{
								type: "mdxJsxAttribute",
								name: "code",
								value: node.value,
							},
							{
								type: "mdxJsxAttribute",
								name: "language",
								value: node.lang ?? "",
							},
							{
								type: "mdxJsxAttribute",
								name: "class",
								value: "source-map-" + node.position?.start.line,
							},
						],
						sourceMapRef: node.position?.start.line,
						position: node.position,
						children: [] as Node[],
					};

					if ("children" in parent) {
						parent.children[index] = component;
					}
				}
			},
		);
	};
};

/**
 * Rewrite `<a>` elements into `Link` component instances.
 */
const rewriteLinks: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RehypeElement = Node & {
		tagName: string;
		properties?: Record<string, unknown>;
		children: Node[];
	};

	return (tree) => {
		visit(
			tree,
			"element",
			(node: RehypeElement, index, parent: RehypeElement) => {
				if (node.tagName === "a") {
					const href = node.properties?.href as string;

					if (href) {
						const component = {
							type: "element",
							tagName: "Link",
							children: node.children,
							position: node.position,
							properties: {
								href,
								newTab: !href.startsWith("/"),
							},
						};

						if (parent && index) {
							parent.children[index] = component;
						}
					}
				}
			},
		);
	};
};

/**
 * Render KaTeX math expressions.
 */
const renderKaTeX: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RehypeElement = Node & {
		type: "element";
		tagName: string;
		value: string;
		properties?: Record<string, unknown>;
		children: (Node & { value: string })[];
	};

	return (tree) => {
		visitParents(
			tree,
			"element",
			(element: RehypeElement, parents: RehypeElement[]) => {
				const classes = Array.isArray(element.properties?.className)
					? element.properties.className
					: [];

				// Generated by remark-math with $$…$$.
				const isMathDisplay = classes.includes("math-display");

				// Generated by remark-math with $…$.
				const isMathInline = classes.includes("math-inline");

				if (!isMathDisplay && !isMathInline) {
					return;
				}

				try {
					// Get the KaTeX expression.
					const mathExpression = element.children[0].value;

					// Render the KaTeX expression.
					const result: string = KaTeX.renderToString(mathExpression, {
						displayMode: isMathDisplay,
						throwOnError: true,
					});

					// Create new element with rendered expression.
					const render = {
						type: "element",
						value: "<satisfy-type-decl>",
						tagName: isMathDisplay ? "div" : "span",
						position: element.position,
						properties: {
							innerHTML: result,
						},
					};

					// Replace unrendered element with rendered element.
					const parent = parents[parents.length - 1];
					const index = parent.children.indexOf(element);
					parent.children.splice(index, 1, render);
				} catch (e) {
					console.error("Failed to render KaTeX:", e);
				}

				return SKIP;
			},
		);
	};
};

const createSourceMap =
	(setSourceMap: Setter<SourceMap>): Plugin =>
	() => {
		type Location = {
			line: number;
			column: number;
			offset: number;
		};

		type Position = {
			start: Location;
			end: Location;
		};

		type RehypeElement = {
			type: "element";
			tagName: string;
			properties?: Record<string, any>;
			position?: Position;
			sourceMapRef?: number;
			children: Node[];
		};

		const sourceMap: SourceMap = {};

		return (tree) => {
			// Visit JSX elements.
			let cursor: number = 1;

			visit(tree, "mdxJsxFlowElement", (node: RehypeElement) => {
				const start = node?.position?.start?.line ?? null;
				const end = node?.position?.end?.line ?? null;
				const sourceMapRef = node.sourceMapRef;

				if (start != null && end != null && node.sourceMapRef != null) {
					// [TODO] Handle overlapping elements.
					if (cursor > start) {
						return;
					}

					// Update the source map.
					const block: ElementBlock = {
						type: "element",
						start,
						end,
						selector: `.source-map-${sourceMapRef}`,
					};

					for (let i = start; i <= end; i++) {
						sourceMap[i] = block;
					}

					// Update the cursor.
					cursor = end;
				}
			});

			// Visit HTML elements.
			cursor = 1;

			visit(tree, "element", (node: RehypeElement) => {
				const start = node?.position?.start?.line ?? null;
				const end = node?.position?.end?.line ?? null;

				if (start != null && end != null) {
					// [TODO] Handle overlapping elements.
					if (cursor > start) {
						return;
					}

					// Annotate the element with the source map class.
					node.properties = node.properties ?? {};
					node.properties.className = node.properties.className ?? [];
					node.properties.className.push(`source-map-${start}`);

					// Update the source map.
					const block: ElementBlock = {
						type: "element",
						start,
						end,
						selector: `.source-map-${start}`,
					};

					for (let i = start; i <= end; i++) {
						sourceMap[i] = block;
					}

					// Update the cursor.
					cursor = end;
				}
			});

			// Fill in the gaps with empty blocks.
			const keys = Object.keys(sourceMap).map((key) => parseInt(key));

			for (let i = 1; i < keys.length; i++) {
				const previous = sourceMap[keys[i - 1]] as ElementBlock;
				const next = sourceMap[keys[i]] as ElementBlock;

				if (next.start - previous.end > 1) {
					const block: EmptyBlock = {
						type: "empty",
						start: previous.end + 1,
						end: next.start - 1,
						previous,
						next,
					};

					for (let j = previous.end + 1; j < next.start; j++) {
						sourceMap[j] = block;
					}
				}
			}

			setSourceMap(sourceMap);
		};
	};

export { compileMdx };
