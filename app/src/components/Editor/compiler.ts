import { evaluate } from "@mdx-js/mdx";
import { Effect } from "effect";
import { UnknownException } from "effect/Cause";
import remarkMath from "remark-math";
import KaTeX from "katex";
import { JSX } from "solid-js";
import * as runtime from "solid-js/h/jsx-runtime";
import { Plugin } from "unified";
import { Node, Parent } from "unist";
import { visit } from "unist-util-visit";
import { SKIP, visitParents } from "unist-util-visit-parents";
import { CodeBlock } from "~/components/CodeBlock";
import { Link } from "~/components/Link";

/**
 * A component registry that maps component names to components.
 * Components must be registered here to be used in MDX content.
 */
const componentRegistry = {
	CodeBlock,
	Link,
};

/**
 * An effect that compiles MDX content into JSX.
 */
const compileMdx = (
	mdx: string,
): Effect.Effect<JSX.Element, UnknownException> => {
	return Effect.tryPromise(async () => {
		try {
			const { default: renderContent } = await evaluate(mdx, {
				...runtime,
				remarkPlugins: [remarkMath, rewriteCodeBlocks],
				rehypePlugins: [renderKaTeX, rewriteLinks],
			});

			return renderContent({
				components: componentRegistry,
			});
		} catch (e) {
			return Effect.fail(new Error(`Failed to compile MDX: ${e}`));
		}
	});
};

/**
 * Rewrite code block elements into `CodeBlock` component instances.
 */
const rewriteCodeBlocks: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RemarkCode = (Node | Parent) & {
		lang: string;
		value: string;
	};

	return (tree) => {
		visit(tree, "code", (node: RemarkCode, index, parent: RemarkCode) => {
			if (parent != null && index != null) {
				const component = {
					type: "mdxJsxFlowElement",
					name: "CodeBlock",
					attributes: [
						{
							type: "mdxJsxAttribute",
							name: "code",
							value: node.value,
						},
						{
							type: "mdxJsxAttribute",
							name: "language",
							value: node.lang ?? "",
						},
					],
					children: [] as Node[],
				};

				if ("children" in parent) {
					parent.children[index] = component;
				}
			}
		});
	};
};

/**
 * Rewrite `<a>` elements into `Link` component instances.
 */
const rewriteLinks: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RehypeElement = {
		tagName: string;
		properties?: Record<string, unknown>;
		children: Node[];
	};

	return (tree) => {
		visit(
			tree,
			"element",
			(node: RehypeElement, index, parent: RehypeElement) => {
				if (node.tagName === "a") {
					const href = node.properties?.href as string;

					if (href) {
						const component = {
							type: "element",
							tagName: "Link",
							children: node.children,
							properties: {
								href,
								newTab: !href.startsWith("/"),
							},
						};

						if (parent) {
							parent.children[index] = component;
						}
					}
				}
			},
		);
	};
};

/**
 * Render KaTeX math expressions in MDX content.
 */
const renderKaTeX: Plugin = () => {
	// Inferred from the console output.
	// Does this type exist somewhere?
	type RehypeElement = {
		type: "element";
		tagName: string;
		value: string;
		properties?: Record<string, unknown>;
		children: (Node & { value: string })[];
	};

	return (tree) => {
		visitParents(
			tree,
			"element",
			(element: RehypeElement, parents: RehypeElement[]) => {
				const classes = Array.isArray(element.properties?.className)
					? element.properties.className
					: [];

				// Generated by remark-math with $$…$$.
				const isMathDisplay = classes.includes("math-display");

				// Generated by remark-math with $…$.
				const isMathInline = classes.includes("math-inline");

				if (!isMathDisplay && !isMathInline) {
					// Skip.
					return;
				}

				// Get the parent element.
				const parent = parents[parents.length - 1];

				try {
					// Get the KaTeX expression.
					const mathExpression = element.children[0].value;

					// Render the KaTeX expression.
					const result: string = KaTeX.renderToString(mathExpression, {
						displayMode: isMathDisplay,
						throwOnError: true,
					});

					// Replace the element with the KaTeX result.
					const index = parent.children.indexOf(element);

					// Determine the tag name.
					const tagName = isMathDisplay ? "div" : "span";

					// New element.
					const resultElement = {
						type: "element",
						tagName,
						value: "",
						properties: {
							innerHTML: result,
						},
					};

					parent.children.splice(index, 1, resultElement);
				} catch (e) {
					console.error("Failed to render KaTeX:", e);
				}

				return SKIP;
			},
		);
	};
};

export { compileMdx };
